{
  "MasterBlueprint": {
    "_comment": "Master annotated JSON Blueprint for Secure Device Control System (Academic Simulation). Use this as the canonical architecture document for engineering handoff and the academic report.",
    "version": "1.0",
    "project": "Secure Device Control System (Academic Simulation)",
    "created_at": "2025-10-29T14:00:00Z",
    "author": "Felix Eladi",
    "context": {
      "_comment": "High-level purpose and constraints.",
      "purpose": "Secure and auditable device control between a user’s Windows PC and their mobile app via FastAPI + Laravel backend.",
      "environment": "Controlled academic lab",
      "security_scope": "Simulated only; no live or unauthorized use. All operations require explicit consent and legal authority."
    },

    "Flows": {
      "_comment": "All primary runtime flows (0 through 7). Each flow contains sequence steps, request/process/response, security notes and error paths.",
      
      "0. DiscoveryFlow": {
        "_comment": "Enables unpaired Windows agents to announce availability securely without exposing raw identifiers.",
        "Purpose": "Enable unpaired Windows agents to securely advertise availability to the backend without revealing sensitive data.",
        "Sequence": [
          {
            "Step": "Agent bootstraps discovery broadcast",
            "Request": {
              "from": "WindowsAgent",
              "to": "FastAPI",
              "method": "WSS connect (unauthenticated handshake)",
              "body": {
                "hwid_hash": "sha256(HW123)",
                "nonce": "rand128",
                "version": "1.0.0",
                "agent_manifest_hash": "sha256(agent_exe)"
              }
            },
            "Process": "FastAPI validates payload structure, rate-limits source, issues signed challenge_token.",
            "Response": {
              "from": "FastAPI",
              "to": "WindowsAgent",
              "body": {
                "challenge_token": "jwt(challenge, exp=60s)",
                "pair_init_url": "https://api.example.com/pair/request",
                "expires_in": "60"
              }
            },
            "_comment": "Purpose: avoid TOFU and reduce spoofing; handshake uses ephemeral challenge token."
          },
          {
            "Step": "Agent completes discovery challenge",
            "Request": {
              "from": "WindowsAgent",
              "to": "FastAPI",
              "method": "POST /api/discovery/confirm",
              "body": {
                "hwid_hash": "sha256(HW123)",
                "challenge_token": "jwt(...)",
                "nonce_response": "rand128_signed"
              }
            },
            "Process": "FastAPI verifies challenge, creates ephemeral discovery_session (TTL=10 min).",
            "Response": {
              "from": "FastAPI",
              "to": "Laravel",
              "action": "POST /webhook/discovery_event",
              "body": {
                "hwid_hash": "sha256(HW123)",
                "version": "1.0.0",
                "timestamp": "2025-10-29T10:10Z"
              }
            },
            "_comment": "Outcome: device appears in 'Pending Pairing' with hashed id; TTL enforces ephemeral state."
          }
        ],
        "Security": {
          "Privacy": "Hardware identifiers are hashed; no telemetry transmitted in discovery.",
          "Integrity": "agent_manifest_hash verified against allowed fingerprints list in Laravel admin.",
          "ReplayProtection": "challenge_token expires after 60s.",
          "RateLimit": "max 3 discovery attempts / 5 min per device."
        },
        "Outcome": "Device visible in 'Pending Pairing' list for user's account until explicit pairing or TTL expiry (10 min)."
      },

      "1. PairingFlow": {
        "_comment": "Pairing flow: binds a mobile user to a device (Windows Agent). Laravel acts as root of trust during pairing.",
        "Purpose": "Securely associate a Windows Agent with a user's mobile app via Laravel backend and FastAPI controller.",
        "Sequence": [
          {
            "Step": "Mobile registers user",
            "Request": {
              "from": "MobileApp",
              "to": "Laravel",
              "method": "POST /api/register",
              "body": {
                "email": "user@example.com",
                "pubkey": "MobilePub"
              }
            },
            "Process": "Laravel creates user record, stores MobilePub, issues JWT.",
            "Response": {
              "from": "Laravel",
              "to": "MobileApp",
              "body": {
                "jwt": "user_token",
                "user_id": "UID001"
              }
            },
            "Security": {
              "auth": "JWT signed by LaravelPriv",
              "verify": "Mobile verifies JWT using LaravelPub"
            },
            "Next": "Agent pairing initialization"
          },
          {
            "Step": "Agent pairing request",
            "Request": {
              "from": "WindowsAgent",
              "to": "Laravel",
              "method": "POST /api/pair/request",
              "body": {
                "device_name": "UserLaptop",
                "hwid": "HW123",
                "pubkey": "AgentPub"
              }
            },
            "Process": "Laravel stores device record and signs pair_token JWT tied to AgentPub.",
            "Response": {
              "from": "Laravel",
              "to": "WindowsAgent",
              "body": {
                "pair_token": "jwt_pair_token",
                "expires": "5min"
              }
            },
            "Security": {
              "auth": "JWT issued by LaravelPriv",
              "verify": "Agent verifies using LaravelPub",
              "pair_token": {
                "ttl": "5min",
                "nonce": "unique"
              }
            },
            "Next": "Agent displays QR containing pair_token for mobile scan"
          },
          {
            "Step": "Mobile completes pairing",
            "Request": {
              "from": "MobileApp",
              "to": "Laravel",
              "method": "POST /api/pair/confirm",
              "body": {
                "pair_token": "jwt_pair_token"
              }
            },
            "Process": "Laravel validates pair_token, links user↔device, generates mTLS cert for Agent and registers device ownership. Laravel notifies FastAPI via /webhook/device/paired.",
            "Response": {
              "from": "Laravel",
              "to": "WindowsAgent",
              "method": "Webhook /device/activate",
              "body": {
                "device_id": "PC001",
                "cert": "SignedDeviceCert"
              }
            },
            "Audit": "Laravel logs event 'device_paired' with timestamp, user_id and source IP.",
            "Next": "Agent authenticates with FastAPI"
          },
          {
            "Step": "Agent authenticates with FastAPI",
            "Request": {
              "from": "WindowsAgent",
              "to": "FastAPI",
              "method": "WSS connect",
              "body": {
                "type": "auth",
                "cert": "SignedDeviceCert"
              }
            },
            "Process": "FastAPI validates cert via Laravel introspection (JWT or cert-check endpoint), creates Redis presence entry and session id.",
            "Response": {
              "from": "FastAPI",
              "to": "WindowsAgent",
              "body": {
                "status": "ok",
                "device_id": "PC001",
                "session_id": "sess-789"
              }
            },
            "Next": "Device is ready for commands and telemetry"
          }
        ],
        "ErrorPaths": {
          "jwt_expired": "Laravel returns 401, user must re-scan QR or regenerate pairing token.",
          "invalid_qr": "Laravel rejects pairing with code 403; show clear UI message.",
          "hwid_conflict": "Existing device with same HWID exists → return 409 Conflict; escalate to admin."
        }
      },

      "2. CommandExecutionFlow": {
        "_comment": "Core command pipeline: Mobile → Laravel → Redis → FastAPI → Agent → KernelService → Agent → FastAPI → Laravel → Mobile",
        "Purpose": "Secure, auditable, and reliable forwarding of commands from Mobile → Laravel → FastAPI → Agent → KernelService with full lifecycle, retries, streaming results, and audit.",
        "Actors": [
          "MobileApp",
          "Laravel (API + Auth)",
          "Redis (streams & DLQ)",
          "FastAPI (Controller)",
          "WindowsAgent (SYSTEM)",
          "KernelService (user-mode privileged helper)",
          "ObjectStore (S3/MinIO)",
          "AnalyticsWorker"
        ],
        "Preconditions": {
          "device_registered": true,
          "device_online_or_queued": true,
          "user_authorized": true,
          "command_allowed_by_policy": true,
          "queue_limit": 3
        },
        "CommandSchema": {
          "_comment": "Canonical command envelope. 'sig' is applied to canonical JSON (lexicographic key order) and includes 'kid'.",
          "message_id": "UUID",
          "trace_id": "UUID",
          "seq": 123,
          "header": {
            "version": "1.1",
            "timestamp": "ISO8601",
            "ttl_seconds": 300,
            "priority": "normal",
            "requires_ack": true,
            "long_running": false
          },
          "body": {
            "method": "string",
            "params": {},
            "sensitive": false
          },
          "meta": {
            "device_id": "PC001",
            "origin_user_id": "UID001",
            "enc": "none|aes256gcm",
            "enc_key_id": "key-id"
          },
          "sig": "base64-ed25519-or-hmac"
        },
        "LifecycleStates": [
          "queued",
          "sent",
          "ack_received",
          "executing",
          "result_posted",
          "completed",
          "failed"
        ],
        "Sequence": [
          {
            "Step": "Mobile sends command to Laravel (ingest)",
            "Request": {
              "from": "MobileApp",
              "to": "Laravel",
              "method": "POST /api/command",
              "body": {
                "message_id": "CMD-0001-uuid",
                "trace_id": "TRACE-0001",
                "seq": 1,
                "timestamp": "2025-10-29T11:00:00Z",
                "ttl_seconds": 300,
                "device_id": "PC001",
                "method": "lock_screen",
                "params": {},
                "sensitive": false,
                "signature": "sig_mobile"
              }
            },
            "Process": "Laravel authenticates user JWT, checks RBAC & policy (two-person approval or 2FA for destructive commands). Canonicalizes JSON, signs a server envelope (sig_laravel). Inserts command row in MySQL (state=queued) and publishes to Redis stream: stream:device:PC001. Applies rate-limits and quota checks.",
            "Response": {
              "from": "Laravel",
              "to": "MobileApp",
              "body": {
                "status": "accepted",
                "command_id": "CMD-0001-uuid",
                "state": "queued",
                "queued_at": "2025-10-29T11:00:00Z"
              }
            },
            "Audit": "Insert audit {event:'command_ingest', actor:UID001, message_id, hash:sha256(payload), signature:sig_laravel}"
          },
          {
            "Step": "FastAPI consumes the command and decides routing",
            "Request": {
              "from": "FastAPI",
              "to": "Redis",
              "action": "XREADGROUP group=workers stream:device:PC001 >"
            },
            "Process": "FastAPI validates Laravel signature, verifies command TTL & seq, checks device presence (Redis presence map). If device online, attempt delivery; else persist as queued and set dead-letter policy. Attach trace metadata. If queue_full, mark state 'backpressure' and respond to Laravel to inform user.",
            "Response": {
              "from": "FastAPI",
              "to": "Laravel",
              "body": {
                "status": "dispatched|queued|backpressure",
                "command_id": "CMD-0001-uuid"
              }
            }
          },
          {
            "Step": "FastAPI sends command envelope to Agent (WSS)",
            "Request": {
              "from": "FastAPI",
              "to": "WindowsAgent",
              "protocol": "WSS",
              "body": {
                "header": {
                  "message_id": "CMD-0001-uuid",
                  "trace_id": "TRACE-0001",
                  "seq": 1,
                  "timestamp": "2025-10-29T11:00:05Z",
                  "ttl_seconds": 300,
                  "requires_ack": true,
                  "long_running": false
                },
                "body": {
                  "method": "lock_screen",
                  "params": {}
                },
                "meta": {
                  "device_id": "PC001",
                  "origin": "laravel"
                },
                "sig": "sig_laravel_over_envelope"
              }
            },
            "Process": "Agent validates envelope signature (FastAPIPub/LaravelPub depending on signing scheme), checks seq > last_seq, verifies TTL. If invalid, sends error to FastAPI. If valid, Agent persists envelope to local encrypted SQLite queue (reliability) and emits 'ack_received' to FastAPI.",
            "Response": {
              "from": "WindowsAgent",
              "to": "FastAPI",
              "protocol": "WSS",
              "body": {
                "type": "ack",
                "message_id": "CMD-0001-uuid",
                "status": "received",
                "received_at": "2025-10-29T11:00:06Z"
              }
            },
            "StateChange": "MySQL update command state -> 'sent' -> 'ack_received'"
          },
          {
            "Step": "Agent executes command via KernelService (IOCTL, sandboxed if dangerous)",
            "Request": {
              "from": "WindowsAgent",
              "to": "KernelService",
              "protocol": "IOCTL",
              "body": {
                "opcode": "EXEC_LOCK_SCREEN",
                "message_id": "CMD-0001-uuid",
                "params": {}
              }
            },
            "Process": "KernelService performs privileges check, maps opcode to safe, enumerated action. For sensitive operations, KernelService enforces extra confirmation or denies if policy disallows. For long_running commands, KernelService spawns supervisor thread and streams incremental status back to Agent.",
            "Response": {
              "from": "KernelService",
              "to": "WindowsAgent",
              "protocol": "IOCTL",
              "body": {
                "status": "executing|ok|failed",
                "exec_id": "exec-xyz",
                "start_time": "2025-10-29T11:00:07Z",
                "error_code": null
              }
            },
            "StateChange": "MySQL update state -> 'executing'"
          },
          {
            "Step": "Agent posts execution result (small result) or uploads artifact (large result)",
            "Request": {
              "from": "WindowsAgent",
              "to": "FastAPI",
              "protocol": "WSS or multipart",
              "body": {
                "type": "response",
                "message_id": "CMD-0001-uuid",
                "result": {
                  "status": "ok",
                  "notes": ""
                },
                "artifact": null,
                "signature": "sig_agent"
              }
            },
            "Process": "If result small, embed in envelope and sign. If result large (screenshot, dump), Agent requests presigned upload URL from Laravel (/api/artifact/request) and uploads encrypted artifact to object store, then returns artifact URL in `result.artifact_url` and checksum. FastAPI validates Agent signature, stores pointer in MySQL, and publishes result to Redis result stream.",
            "Response": {
              "from": "FastAPI",
              "to": "Laravel",
              "method": "POST /api/command/result",
              "body": {
                "command_id": "CMD-0001-uuid",
                "status": "completed",
                "result_summary": {
                  "status": "ok"
                },
                "artifact_url": null,
                "timestamp": "2025-10-29T11:00:10Z",
                "signature": "sig_fastapi"
              }
            },
            "StateChange": "MySQL update -> 'result_posted' -> 'completed'"
          },
          {
            "Step": "Laravel notifies Mobile (push/WSS) and logs audit",
            "Request": {
              "from": "Laravel",
              "to": "MobileApp",
              "method": "Push/WSS",
              "body": {
                "command_id": "CMD-0001-uuid",
                "trace_id": "TRACE-0001",
                "status": "completed",
                "result": {
                  "status": "ok"
                },
                "timestamp": "2025-10-29T11:00:11Z",
                "sig": "sig_laravel"
              }
            },
            "Process": "Mobile verifies signature, updates UI. Laravel appends immutable audit record {who, when, command_hash, evidence_pointer}. AnalyticsWorker records latency & success rate metric.",
            "Response": {
              "from": "MobileApp",
              "to": "Laravel",
              "body": {
                "status": "ack_viewed",
                "timestamp": "2025-10-29T11:00:12Z"
              }
            }
          }
        ],
        "LongRunningCommands": {
          "Support": true,
          "Behavior": {
            "open_stream": true,
            "partial_results": "sent as stream-chunks with chunk_id and seq",
            "keepalive": "30s ping",
            "cancel": {
              "method": "cancel_command",
              "payload": {
                "message_id": "CMD-0001-uuid"
              }
            },
            "restartable": false
          },
          "ArtifactHandling": {
            "large_result": "upload to S3 via presigned URL; return artifact pointer",
            "artifact_encryption": "SSE + client-side AES-GCM optional"
          }
        },
        "RetriesAndDLQ": {
          "send_retries": 3,
          "execution_retries": 1,
          "backoff_policy": [
            30,
            120,
            600
          ],
          "dead_letter_behavior": "after retries -> move to stream:dlq:device:PC001 and set command state=failed; notify operator"
        },
        "Security": {
          "signing": {
            "algo": "Ed25519 or RSA-PSS",
            "canonicalization": "lexicographic keys, no whitespace"
          },
          "encryption": {
            "payload_enc": "aes256gcm optional",
            "enc_key_rotation_days": 90
          },
          "auth": {
            "agent_auth": "JWT + optional mTLS",
            "user_auth": "JWT + 2FA for critical ops"
          },
          "policy": {
            "sensitive_methods": [
              "memory_dump",
              "password_exfil"
            ],
            "require_2fa": true
          }
        },
        "ErrorPaths": {
          "invalid_signature": {
            "detect": "sig_verify == false",
            "action": [
              "drop",
              "log audit with code SIGNATURE_INVALID(2001)",
              "notify Laravel / security webhook"
            ]
          },
          "ttl_expired": {
            "detect": "timestamp + ttl < server_time",
            "action": [
              "do not deliver",
              "set state 'expired'",
              "notify originator"
            ]
          },
          "device_offline": {
            "detect": "no WSS connection",
            "action": [
              "persist to Redis stream & MySQL",
              "notify originator 'device_offline'"
            ],
            "retry": "deliver on reconnect"
          },
          "kernel_failure": {
            "detect": "KernelService responds with status failed or exec crash",
            "action": [
              "capture kernel logs",
              "attempt one auto-retry",
              "if fail -> rollback & mark failed",
              "escalate high severity"
            ]
          },
          "backpressure_queue_full": {
            "detect": "local queue length >= queue_limit",
            "action": [
              "FastAPI returns 'backpressure' to Laravel",
              "Laravel informs user and can escalate to manual override"
            ]
          }
        },
        "Audit": {
          "fields": [
            "event_id",
            "message_id",
            "trace_id",
            "actor",
            "device_id",
            "action",
            "state",
            "timestamp",
            "payload_hash",
            "signature"
          ],
          "storage": "MySQL append-only + S3 replication for evidence",
          "retention": {
            "hot": "90d",
            "cold": "3y"
          }
        },
        "Observability": {
          "metrics": [
            "command_ingest_rate",
            "dispatch_latency_ms",
            "execution_time_ms",
            "success_rate",
            "dlq_count"
          ],
          "tracing": "propagate trace_id across components, connect to distributed tracing system (Jaeger/Zipkin)",
          "logs": "structured JSON logs with log-level and trace_id"
        },
        "TestingHooks": {
          "simulate_command": "/api/test/command?simulate=kernel_failure|slow|success",
          "fault_injection": "available in staging"
        },
        "Next": "Integrate step into CI tests, implement worker to consume DLQ, and provide dashboard for manual re-run and evidence download"
      },

      "3. TelemetryFlow": {
        "_comment": "Real-time telemetry and heartbeat streaming from Agent to analytics and dashboard via FastAPI and Redis.",
        "Purpose": "Real-time, authenticated telemetry and heartbeat stream between Agent and backend for monitoring, analytics, and alerting.",
        "Actors": [
          "WindowsAgent",
          "FastAPI (Controller)",
          "Redis (Pub/Sub Stream)",
          "AnalyticsWorker",
          "RollupWorker",
          "Laravel Dashboard"
        ],
        "Sequence": [
          {
            "Step": "Agent connects and authenticates",
            "Request": {
              "from": "WindowsAgent",
              "to": "FastAPI",
              "protocol": "WSS",
              "body": {
                "auth": {
                  "jwt": "agent_signed_token",
                  "nonce": "unique_counter_1234"
                },
                "device_id": "PC001",
                "session_start": "2025-10-29T10:00Z"
              }
            },
            "Process": "FastAPI verifies JWT, validates nonce, registers live session in Redis (set agent:online:PC001).",
            "Response": {
              "from": "FastAPI",
              "to": "WindowsAgent",
              "body": {
                "status": "connected",
                "intervals": {
                  "heartbeat": "30s",
                  "telemetry": "60s"
                }
              }
            },
            "Next": "Begin telemetry + heartbeat"
          },
          {
            "Step": "Agent sends telemetry",
            "Request": {
              "from": "WindowsAgent",
              "to": "FastAPI",
              "protocol": "WSS",
              "body": {
                "type": "telemetry",
                "timestamp": "2025-10-29T10:10Z",
                "metrics": {
                  "cpu": "12%",
                  "ram": "45%",
                  "disk_usage": "60%",
                  "network_tx": "2.3Mbps",
                  "network_rx": "1.8Mbps"
                },
                "signature": "sig_agent"
              }
            },
            "Process": "FastAPI verifies signature, timestamps event, attaches session metadata, and publishes to Redis telemetry stream.",
            "Response": {
              "from": "FastAPI",
              "to": "Redis",
              "action": "XADD stream:telemetry:PC001",
              "payload": "validated telemetry event"
            },
            "Next": "Analytics and Rollup"
          },
          {
            "Step": "Agent sends heartbeat",
            "Request": {
              "from": "WindowsAgent",
              "to": "FastAPI",
              "protocol": "WSS",
              "body": {
                "type": "heartbeat",
                "timestamp": "2025-10-29T10:10Z",
                "status": "alive"
              }
            },
            "Process": "FastAPI updates Redis key TTL (agent:online:PC001) to maintain liveness.",
            "Response": {
              "from": "FastAPI",
              "to": "Redis",
              "action": "EXPIRE agent:online:PC001 60"
            },
            "Next": "Continue regular heartbeats"
          },
          {
            "Step": "Analytics pipeline processes telemetry",
            "Request": {
              "from": "AnalyticsWorker",
              "to": "Redis",
              "action": "XREADGROUP telemetry",
              "payload": "consume new telemetry events"
            },
            "Process": "Worker enriches event with geolocation, context, and risk scoring. Flags anomalies (e.g., overheating, high CPU).",
            "Response": {
              "from": "AnalyticsWorker",
              "to": "MySQL",
              "action": "INSERT telemetry_events",
              "body": {
                "device_id": "PC001",
                "cpu": "12%",
                "ram": "45%",
                "risk_score": 0.2,
                "status": "Normal activity"
              }
            },
            "Next": "Optional alert feedback if risk_score > 0.8"
          },
          {
            "Step": "Alert feedback to Agent or Dashboard",
            "Condition": "risk_score > 0.8 OR anomaly_detected == true",
            "Request": {
              "from": "Laravel",
              "to": "FastAPI",
              "action": "publish_alert",
              "body": {
                "device_id": "PC001",
                "alert_type": "High CPU Usage",
                "severity": "critical",
                "message": "CPU sustained above 90% for 5 minutes"
              }
            },
            "Process": "FastAPI relays alert via WSS to dashboard and agent subscribers.",
            "Response": {
              "from": "FastAPI",
              "to": [
                "WindowsAgent",
                "Laravel Dashboard"
              ],
              "protocol": "WSS",
              "body": {
                "event": "alert_push",
                "severity": "critical",
                "details": "High CPU Usage"
              }
            }
          },
          {
            "Step": "Rollup aggregation worker",
            "Request": {
              "from": "RollupWorker",
              "to": "Redis",
              "action": "aggregate hourly metrics from stream:telemetry:*"
            },
            "Process": "Compute average CPU, RAM, network usage per device and store daily/hourly summaries.",
            "Response": {
              "from": "RollupWorker",
              "to": "MySQL",
              "action": "INSERT device_metrics_hourly",
              "body": {
                "device_id": "PC001",
                "avg_cpu": "14%",
                "avg_ram": "48%",
                "avg_network": "moderate",
                "time_window": "2025-10-29T10:00Z"
              }
            }
          },
          {
            "Step": "Dashboard live telemetry subscription",
            "Request": {
              "from": "Laravel Dashboard",
              "to": "FastAPI",
              "protocol": "WSS",
              "action": "subscribe_device_telemetry",
              "body": {
                "device_id": "PC001"
              }
            },
            "Process": "FastAPI streams new telemetry events to subscribed dashboards in real time.",
            "Response": {
              "from": "FastAPI",
              "to": "Laravel Dashboard",
              "body": {
                "event": "telemetry_update",
                "metrics": {
                  "cpu": "13%",
                  "ram": "47%",
                  "network": "active"
                },
                "timestamp": "2025-10-29T10:12Z"
              }
            }
          }
        ]
      },

      "4. KeyManagementFlow": {
        "_comment": "Comprehensive key lifecycle, issuance, rotation, revocation, KMS/HSM integration, and emergency procedures.",
        "Purpose": "Maintain lifecycle of cryptographic material (JWT keys, mTLS certs, signing keys, envelope keys) with HSM-backed root, automated rotation, revocation, and audit.",
        "Actors": [
          "Laravel (CA Authority / Key Manager API)",
          "Vault/KMS (HSM-backed: AWS KMS/GCP KMS/Azure KeyVault/HashiCorp Vault)",
          "FastAPI (JWKS consumer, revocation broadcaster)",
          "WindowsAgent (TPM/DPAPI-bound keys)",
          "MobileApp (platform keystore)",
          "AdminOperator",
          "Analytics/Monitoring"
        ],
        "KeyTypesAndAlgorithms": {
          "root_ca": {
            "algo": "RSA-4096 or ECDSA P-384",
            "storage": "offline HSM",
            "usage": "sign intermediate CAs"
          },
          "intermediate_ca": {
            "algo": "RSA-4096 or ECDSA P-384",
            "storage": "HSM",
            "usage": "issue device & server certs"
          },
          "device_cert": {
            "algo": "ECDSA P-256 or Ed25519",
            "lifetime_days": 365,
            "usage": [
              "mTLS",
              "signing_optional"
            ]
          },
          "jwt_signing": {
            "algo": "Ed25519 or RSASSA-PSS",
            "key_rotation_days": 7,
            "token_ttl_seconds": 900
          },
          "encryption_keys": {
            "algo": "AES-256-GCM",
            "usage": "envelope encryption for sensitive payloads",
            "wrapped_by": "KMS"
          },
          "session_keys": {
            "algo": "ECDH + HKDF",
            "lifetime": "short (per-session)"
          }
        },
        "KeyIdentifiersAndDiscovery": {
          "kid_usage": "All JWTs and signed envelopes must include 'kid' header",
          "jwks_endpoint": "https://auth.example.com/.well-known/jwks.json",
          "jwks_caching_ttl": 300,
          "fingerprint_store": "Redis (fingerprint -> device_id mapping) + MySQL canonical record"
        },
        "Sequence": [
          {
            "Step": "Bootstrap trust (one-time)",
            "Process": "Provision offline Root CA into HSM; create intermediate CA(s) for environments (prod/staging). Store root metadata in vault and distribute trust anchor to internal components.",
            "Output": {
              "root_ca_id": "root-001",
              "intermediate_ca_id": "int-2025-01"
            }
          },
          {
            "Step": "Key issuance during pairing",
            "Trigger": "Successful pairing flow",
            "Process": [
              "Laravel (CA) generates CSR or issues certificate signed by intermediate CA stored in Vault.",
              "Device private key generated on-device and sealed to TPM/DPAPI; public CSR uploaded OR device key material wrapped and stored encrypted.",
              "Laravel records device_cert_fingerprint and kid in MySQL; publishes ephemeral presence to Redis."
            ],
            "Output": {
              "device.crt": "PEM",
              "device.key_wrapped": "base64",
              "fingerprint_id": "fp-abc"
            },
            "Security": "Prefer on-device key generation bound to TPM; if server issues keys, wrap with KMS and require owner confirmation."
          },
          {
            "Step": "JWT & session key issuance",
            "Process": [
              "Short-lived JWTs issued by Laravel Auth service; JWTs signed with rotating key (kid=K1).",
              "Session keys are derived per-connection using ECDH; ephemeral keys not persisted beyond session."
            ],
            "Output": {
              "jwt": "eyJ...",
              "kid": "K1",
              "session_key_meta": "..."
            }
          },
          {
            "Step": "Periodic rotation (automation)",
            "Trigger": "cron OR threshold (age > rotation_days) OR operator request",
            "Process": [
              "Vault/KMS rotates signing keypair (generates new key version)",
              "Laravel publishes new JWKS and begins signing tokens with new key (K2) while still accepting K1 within grace window.",
              "FastAPI and other services hot-reload JWKS from endpoint (dual acceptance for grace_period).",
              "Agents fetch new trust anchor or certs as needed (rolling acceptance)."
            ],
            "Parameters": {
              "rotation_check_interval": "24h",
              "grace_period_seconds": 3600
            }
          },
          {
            "Step": "Zero-downtime rotation (dual acceptance)",
            "Process": [
              "During rotation, validators accept both old_kid and new_kid for grace_period.",
              "Sign new tokens with new_kid; keep old tokens valid until TTL expiry + grace.",
              "Record rotation event in AuditTrail with prev_kid/new_kid mapping."
            ]
          },
          {
            "Step": "Revocation handling (CRL/OCSP + push)",
            "Trigger": "Compromise detected OR admin revokes",
            "Process": [
              "Laravel marks cert revoked in CA DB and updates CRL/OCSP responder (hosted by Vault/CA infra).",
              "FastAPI broadcasts revocation notice over Redis and WSS (revocation_event) to connected agents.",
              "Devices receiving revocation should wipe local keys, disconnect sessions, and enter 're-pair required' state.",
              "CRL/OCSP caches considered: servers and agents should poll OCSP or accept short CRL TTL; implement OCSP stapling for performance."
            ],
            "Output": {
              "crl_url": "https://ca.example.com/crl.pem",
              "ocsp_url": "https://ocsp.example.com"
            }
          },
          {
            "Step": "Compromise / emergency mass-revoke playbook",
            "Trigger": "Detected TAMPER_DETECTED OR key exfiltration",
            "Process": [
              "Mark affected keys as compromised in Vault; increment compromise incident counter.",
              "Issue emergency revoke via FastAPI broadcast and CRL/OCSP update.",
              "Quarantine affected devices in Laravel (disable actions), notify owners and SOC.",
              "Optionally rotate intermediate CA if root of trust compromised (requires offline HSM operation)."
            ],
            "Outputs": [
              "incident_id",
              "affected_device_list",
              "operator_actions_required"
            ]
          },
          {
            "Step": "Key backup & escrow / recovery",
            "Policy": [
              "Root CA private key remains in offline HSM (no export).",
              "Intermediate or server keys stored within HSM or Vault with strict IAM policies.",
              "Device keys: prefer non-exportable TPM-protected keys. If server-side escrow required, wrap keys with KMS and record escrow policy with multi-signature access.",
              "Recovery requires multi-party approval and audit."
            ]
          }
        ],
        "OperationalPolicies": {
          "RBAC": {
            "roles": {
              "operator": [
                "release",
                "rotate_request"
              ],
              "auditor": [
                "view_only"
              ],
              "security_admin": [
                "emergency_revoke"
              ]
            },
            "separation_of_duties": "rotation of root/intermediate requires multi-approver workflow"
          },
          "RotationCadence": {
            "jwt_keys": "7 days (automated)",
            "device_certs": "365 days (rotate earlier on compromise)",
            "intermediate_ca": "2-5 years (HSM-bound manual process)"
          },
          "GraceWindows": {
            "kid_grace_seconds": 3600,
            "cert_revocation_propagation_seconds": 120
          },
          "AllowedAlgorithms": {
            "signing": [
              "Ed25519",
              "RSASSA-PSS:SHA-256"
            ],
            "tls": [
              "ECDSA P-256",
              "RSA-2048+"
            ],
            "encryption": [
              "AES-256-GCM"
            ]
          }
        },
        "MonitoringAndMetrics": {
          "metrics": [
            "key_rotation_success_rate",
            "failed_signature_verifications",
            "ocsp_response_time",
            "crl_publish_time",
            "compromise_incidents"
          ],
          "alerts": {
            "failed_rotation": "pagerduty + email",
            "mass_revocation": "pagerduty + SOC webhook"
          }
        },
        "AuditAndForensics": {
          "AuditStore": "append-only table in MySQL hashed and replicated to S3",
          "Fields": [
            "event_id",
            "actor",
            "operation",
            "key_id",
            "old_kid",
            "new_kid",
            "timestamp",
            "evidence_link",
            "signature"
          ],
          "Retention": {
            "hot": "90d",
            "cold": "7y"
          }
        },
        "TestingHooksAndAutomation": {
          "simulate_rotation": "/api/test/key/rotate?dry_run=true",
          "simulate_revocation": "/api/test/key/revoke?device=PC001",
          "integration_tests": "automated in CI to verify JWKS rotation and dual-accept"
        },
        "EdgeCasesAndNotes": {
          "stale_cert_handling": "If agent cannot fetch new JWKS or CRL, enforce 'grace_attempts' then lock sensitive ops.",
          "bootstrap_trust": "Initial root CA distributed out-of-band or via secure provisioning; avoid TOFU unless explicitly accepted.",
          "cross_env_isolation": "Separate root/intermediate between prod and staging to avoid cross-env trust."
        },
        "Storage": {
          "Vault": "HashiCorp Vault or cloud KMS (HSM-backed) for all private keys except non-exportable TPM device keys",
          "Device": "TPM-sealed or DPAPI-wrapped; fallback to encrypted escrow only for enterprise-managed devices"
        },
        "Next": "Implement JWKS endpoint (/.well-known/jwks.json), OCSP responder, rotation automation cron, and emergency revoke playbook with runbook steps and test drills."
      },

      "5. OTAUpdateFlow": {
        "_comment": "Secure OTA pipeline with staged rollout, presigned downloads, verification, sandboxing, commit/rollback and reporting.",
        "Purpose": "Secure, auditable, and resilient distribution of signed updates from backend to device with staged rollout, verification, rollback and reporting.",
        "Actors": [
          "Laravel (Update Manager)",
          "FastAPI (Controller)",
          "Redis (Control & rollout state)",
          "ObjectStore (S3/MinIO)",
          "WindowsAgent",
          "KernelService",
          "AnalyticsWorker",
          "Laravel Dashboard"
        ],
        "Preconditions": {
          "device_online": true,
          "sufficient_disk": ">= update_size + 2*delta",
          "battery_or_plugged": "battery >= 40% OR AC power",
          "policy": "device_allowed_in_rollout_group",
          "compatibility": "os_build in allowed_builds AND arch in supported_archs"
        },
        "RolloutPolicy": {
          "strategy": "staged",
          "stages": [
            {
              "name": "canary",
              "percentage": 1,
              "criteria": "manual_approve"
            },
            {
              "name": "beta",
              "percentage": 10,
              "criteria": "auto_after_24h_no_crit_errors"
            },
            {
              "name": "general",
              "percentage": 100,
              "criteria": "auto_after_72h_no_crit_errors"
            }
          ],
          "groups": [
            {
              "group_id": "g-canary",
              "selector": {
                "tag": "canary"
              }
            },
            {
              "group_id": "g-beta",
              "selector": {
                "tag": "beta"
              }
            }
          ],
          "rollback_threshold": {
            "error_rate": 0.05,
            "critical_failures": 3
          }
        },
        "Sequence": [
          {
            "Step": "Create update release",
            "Request": {
              "from": "Operator",
              "to": "Laravel",
              "method": "POST /api/updates/create",
              "body": {
                "version": "2.0.1",
                "changelog": "...",
                "package_key": "s3://bucket/updates/agent-2.0.1.bin",
                "sha256": "sha256:abcdef...",
                "signature": "detached_sig_base64",
                "min_os_build": "19041",
                "max_os_build": null,
                "supported_arch": [
                  "x64"
                ],
                "rollout_policy": "staged (canary->beta->general)",
                "release_notes": "..."
              }
            },
            "Process": "Laravel stores release metadata, signs release record, writes rollout plan to Redis and MySQL, and generates pre-signed download URLs for targeted groups.",
            "Response": {
              "from": "Laravel",
              "to": "Operator",
              "body": {
                "release_id": "rel-2025-10-29-001",
                "status": "created"
              }
            },
            "Audit": "Insert audit row {actor, release_id, timestamp, ip, signature_of_metadata}"
          },
          {
            "Step": "FastAPI notifies target devices of available update",
            "Request": {
              "from": "Laravel",
              "to": "FastAPI",
              "method": "POST /webhook/update/announce",
              "body": {
                "release_id": "rel-2025-10-29-001",
                "version": "2.0.1",
                "sha256": "sha256:abcdef...",
                "signed_manifest_url": "https://objectstore/.../manifest.json.sig",
                "presigned_base_url": "https://objectstore/presigned/",
                "rollout_stage": "canary",
                "target_selector": {
                  "tag": "canary"
                }
              }
            },
            "Process": "FastAPI queries Redis to resolve devices matching target_selector and publishes 'update_available' to per-device stream or pushes via WSS if online. Devices not online are queued for later delivery.",
            "Response": {
              "from": "FastAPI",
              "to": "Redis",
              "action": "XADD stream:updates:rel-... payload: {device_id, release_id}"
            }
          },
          {
            "Step": "Agent receives update announcement and performs pre-checks",
            "Request": {
              "from": "FastAPI",
              "to": "WindowsAgent",
              "protocol": "WSS",
              "body": {
                "event": "update_available",
                "release_id": "rel-2025-10-29-001",
                "version": "2.0.1",
                "manifest_url": "https://objectstore/.../manifest.json",
                "presigned_download_url": "https://objectstore/presigned/part/",
                "sha256": "sha256:abcdef...",
                "signature_url": "https://objectstore/.../manifest.json.sig",
                "min_os_build": "19041",
                "policy": {
                  "auto_install": false,
                  "allow_reboot": true
                }
              }
            },
            "Process": "Agent validates event signature (FastAPI/Laravel), verifies that device meets Preconditions (disk, battery, compatibility, policies). If any precondition fails, agent reports refusal with reason.",
            "Response": {
              "from": "WindowsAgent",
              "to": "FastAPI",
              "body": {
                "type": "update_precheck",
                "release_id": "rel-2025-10-29-001",
                "status": "ok|fail",
                "reasons": [
                  "low_disk",
                  "on_battery",
                  "incompatible_build"
                ]
              }
            },
            "Next": "If ok -> request presigned chunked download URL (or use provided URL)."
          },
          {
            "Step": "Agent requests resumable download details (optional)",
            "Request": {
              "from": "WindowsAgent",
              "to": "Laravel",
              "method": "POST /api/updates/download-info",
              "body": {
                "device_id": "PC001",
                "release_id": "rel-2025-10-29-001"
              }
            },
            "Process": "Laravel verifies device authorization for this release (rollout group membership) and returns presigned, chunked download endpoints with expiration and backoff params.",
            "Response": {
              "from": "Laravel",
              "to": "WindowsAgent",
              "body": {
                "download_scheme": "multipart-resumable",
                "parts": 16,
                "part_size": 5242880,
                "presigned_part_urls": [
                  "https://objectstore/presigned/part/1",
                  "..."
                ],
                "manifest_signature": "base64_detached_sig",
                "manifest_cert_chain_url": "https://objectstore/ca-chain.pem",
                "ttl_secs": 900
              }
            }
          },
          {
            "Step": "Agent downloads update (resumable, chunked)",
            "Request": {
              "from": "WindowsAgent",
              "to": "ObjectStore",
              "protocol": "HTTPS GET / PUT",
              "body": {
                "action": "GET part N using presigned URL"
              }
            },
            "Process": "Agent downloads each part, persists to temporary staging area, verifies per-part integrity (Content-MD5) and retries on transient failures (with exponential backoff). Partial progress persisted in encrypted SQLite so download can resume across reboots.",
            "Response": {
              "from": "WindowsAgent",
              "to": "WindowsAgent",
              "body": {
                "download_progress": {
                  "parts_total": 16,
                  "parts_completed": 4,
                  "bytes_downloaded": 20971520
                }
              }
            },
            "Next": "After complete download -> verify manifest & package"
          },
          {
            "Step": "Agent verifies package integrity and authenticity",
            "Request": {
              "from": "WindowsAgent",
              "to": "LocalVerification",
              "action": "verify",
              "body": {
                "package_path": "C:\\agent\\staging\\agent-2.0.1.bin",
                "expected_sha256": "sha256:abcdef...",
                "detached_signature": "manifest.json.sig",
                "trusted_ca_chain": "bundle_from_laravel_or_vault"
              }
            },
            "Process": "Agent computes SHA256 of assembled package, verifies it matches expected_sha256. Then verifies detached signature using Laravel's public key and validates certificate chain (optionally checking CRL/OCSP). If verification fails, agent marks as 'invalid_signature' and aborts.",
            "Response": {
              "from": "WindowsAgent",
              "to": "FastAPI",
              "body": {
                "type": "verify_result",
                "release_id": "rel-...",
                "status": "verified|invalid_signature|hash_mismatch"
              }
            },
            "Next": "If verified -> create pre-install snapshot / backup and proceed to staging"
          },
          {
            "Step": "Agent creates rollback snapshot and stages update in sandbox",
            "Request": {
              "from": "WindowsAgent",
              "to": "KernelService",
              "protocol": "IOCTL",
              "body": {
                "opcode": "STAGE_UPDATE",
                "package_path": "C:\\agent\\staging\\agent-2.0.1.bin",
                "rollback_snapshot_path": "C:\\agent\\backup\\agent-2.0.0.bin",
                "flags": {
                  "sandbox": true,
                  "verify_post_install": true
                }
              }
            },
            "Process": "KernelService verifies package signature again (defense in depth), applies update to a sandboxed location (not yet active), creates a filesystem + config snapshot for rollback, and runs health checks in sandbox (light integration tests).",
            "Response": {
              "from": "KernelService",
              "to": "WindowsAgent",
              "body": {
                "status": "staged",
                "sandbox_id": "sbx-123",
                "health_checks": {
                  "smoke": "pass"
                }
              }
            },
            "Next": "If smoke checks pass -> commit to active; else -> rollback"
          },
          {
            "Step": "Commit or rollback (atomic swap)",
            "Condition": "If staged.health_checks.pass == true",
            "Request": {
              "from": "WindowsAgent",
              "to": "KernelService",
              "protocol": "IOCTL",
              "body": {
                "opcode": "COMMIT_UPDATE",
                "sandbox_id": "sbx-123",
                "atomic_swap": true
              }
            },
            "Process": "KernelService atomically swaps active binaries/configs with staged versions. If any step fails, KernelService performs automatic rollback using snapshot. During commit, agent marks device as 'updating' and prevents other intrusive actions.",
            "Response": {
              "from": "KernelService",
              "to": "WindowsAgent",
              "body": {
                "status": "committed|commit_failed",
                "error": "optional error details"
              }
            }
          },
          {
            "Step": "Optional reboot coordination",
            "Request": {
              "from": "WindowsAgent",
              "to": "WindowsAgent",
              "action": "schedule_reboot",
              "body": {
                "allow_reboot": true,
                "window_start": "2025-10-30T02:00Z",
                "grace_period": 300
              }
            },
            "Process": "If reboot required, agent either performs immediate reboot (if policy allows) or schedules a reboot in a safe window and notifies user via local UI. Agent persists pending-reboot state and will complete install after boot.",
            "Response": {
              "from": "WindowsAgent",
              "to": "FastAPI",
              "body": {
                "type": "update_reboot_scheduled",
                "release_id": "rel-...",
                "reboot_time": "2025-10-30T02:00Z"
              }
            }
          },
          {
            "Step": "Post-install verification & health report",
            "Request": {
              "from": "WindowsAgent",
              "to": "FastAPI",
              "protocol": "WSS",
              "body": {
                "type": "update_result",
                "release_id": "rel-2025-10-29-001",
                "version": "2.0.1",
                "status": "success|partial_success|failed",
                "metrics": {
                  "boot_time_ms": 12000,
                  "service_start_ok": true,
                  "error_logs": []
                },
                "rollback_available": true,
                "rollback_snapshot_id": "snap-2025-10-29-001"
              }
            },
            "Process": "FastAPI routes update_result to Laravel via webhook; Laravel updates MySQL release status and rollout progress, and triggers analytics to compute error rates.",
            "Response": {
              "from": "FastAPI",
              "to": "Laravel",
              "method": "POST /api/update/status",
              "body": {
                "device_id": "PC001",
                "release_id": "rel-2025-10-29-001",
                "status": "success",
                "timestamp": "2025-10-29T10:40Z"
              }
            },
            "Audit": "Laravel appends immutable audit log entry {device_id, release_id, version, sha256, status, timestamp, agent_sig}"
          },
          {
            "Step": "Rollout monitoring & auto-rollback",
            "Request": {
              "from": "AnalyticsWorker",
              "to": "Laravel",
              "action": "evaluate_rollout",
              "body": {
                "release_id": "rel-2025-10-29-001",
                "window": "last_60m"
              }
            },
            "Process": "Analytics computes error_rate, crash_rate, and other KPIs. If rollback thresholds exceeded (see RolloutPolicy.rollback_threshold), Laravel triggers an automatic rollback job for affected devices and pauses further rollout stages.",
            "Response": {
              "from": "Laravel",
              "to": "FastAPI",
              "action": "trigger_rollback",
              "body": {
                "release_id": "rel-...",
                "target": "group/or device list",
                "reason": "high_error_rate"
              }
            }
          },
          {
            "Step": "Rollback execution (if triggered)",
            "Request": {
              "from": "FastAPI",
              "to": "WindowsAgent",
              "protocol": "WSS/stream",
              "body": {
                "action": "perform_rollback",
                "release_id": "rel-2025-10-29-001",
                "rollback_snapshot_id": "snap-2025-10-29-001"
              }
            },
            "Process": "Agent instructs KernelService to restore snapshot (atomic restore). After rollback, agent runs health checks and reports status. Laravel marks device as 'rolled_back' and records audit entries.",
            "Response": {
              "from": "WindowsAgent",
              "to": "Laravel",
              "body": {
                "release_id": "rel-...",
                "device_id": "PC001",
                "status": "rolled_back",
                "timestamp": "..."
              }
            },
            "Audit": "Rollback event appended with cause, operator, and evidence links (logs, package hashes)"
          }
        ],
        "Reporting": {
          "progress_states": [
            "announced",
            "precheck_ok",
            "downloading",
            "verifying",
            "staged",
            "committing",
            "rebooting",
            "success",
            "failed",
            "rolled_back"
          ],
          "webhooks": {
            "on_state_change": "/webhook/update/state_change",
            "on_completion": "/webhook/update/status"
          },
          "metrics": [
            "download_time_ms",
            "install_time_ms",
            "error_codes",
            "rollback_count"
          ],
          "artifact_links": {
            "logs_url_field": "artifact_url",
            "trace_id": "trace-uuid"
          }
        },
        "Security": {
          "signing": {
            "release_manifest_signed_by": "LaravelPriv (or KMS/HSM)",
            "detached_signature": true,
            "signature_algo": "Ed25519 or RSA-PSS"
          },
          "integrity": {
            "package_hash": "sha256",
            "verify_chain": true,
            "ocsp_crl_check": "optional"
          },
          "transport": {
            "wss_tls": true,
            "mtls_optional": true,
            "presigned_url_ttl": 900
          },
          "local_protections": {
            "storage_encryption": "AES-256-GCM on staging path",
            "privilege_check": "agent runs install via KernelService with proper ACLs",
            "sig_verify_in_kernel": "optional defense-in-depth"
          },
          "secrets": "Signed manifests and keys stored in KMS/Vault; device keys in DPAPI/TPM"
        },
        "ErrorPaths": {
          "download_failed": {
            "detection": "part_retries_exceeded || network_unavailable",
            "action": "retry_policy with exponential backoff; if persistently failing -> mark release attempt 'failed_download' and report to Laravel"
          },
          "verify_failed": {
            "detection": "sha256_mismatch || signature_invalid || cert_chain_invalid",
            "action": "abort_installation, delete_staging, report 'invalid_package' and alert operator"
          },
          "precheck_failed": {
            "detection": "low_disk || on_battery || incompatible_build",
            "action": "defer_update, notify owner via local UI, attempt later per policy"
          },
          "commit_failed": {
            "detection": "atomic_swap_error || post_commit_smoke_fail",
            "action": "auto_rollback_to_snapshot, report 'commit_failed' with logs and create incident"
          },
          "post_reboot_failure": {
            "detection": "service_not_running || repeated_crash",
            "action": "auto_rollback_if_snapshot_available; escalate to operator and mark device for manual remediation"
          },
          "policy_violation": {
            "detection": "device not in rollout group but attempted to download",
            "action": "revoke presigned URL, mark attempt and alert security"
          }
        },
        "Audit": {
          "immutable_logs": "append-only audit table in MySQL with hash-chain for tamper detection",
          "fields": [
            "event_id",
            "actor",
            "device_id",
            "release_id",
            "action",
            "status",
            "timestamp",
            "evidence_link",
            "signature"
          ],
          "retention": {
            "hot": "90d",
            "cold": "3y",
            "export_on_request": "yes"
          }
        },
        "Next": "Monitor rollout via Analytics; progress to next stage automatically or after manual approval; integrate with incident response playbooks when thresholds exceeded."
      },

      "6. ErrorRecoveryFlow": {
        "_comment": "Error detection, self-heal, escalation and audit chain design.",
        "Purpose": "Ensure system reliability under network failure, data corruption, or tamper scenarios through autonomous recovery, audit, and escalation.",
        "ErrorCodes": {
          "NET_TIMEOUT": 1001,
          "TLS_FAILURE": 1002,
          "SIGNATURE_INVALID": 2001,
          "CERT_EXPIRED": 2002,
          "TAMPER_DETECTED": 3001,
          "DISK_FULL": 4001,
          "UPDATE_FAILURE": 5001,
          "UNKNOWN": 9999
        },
        "DetectionLayer": {
          "Monitors": [
            "Network connectivity via WSS ping/pong",
            "Message signature verification",
            "Kernel tamper telemetry",
            "Disk usage and health checks",
            "Component heartbeat status"
          ],
          "Interval": "60s",
          "FailureThreshold": 2
        },
        "RecoveryLayer": {
          "NetworkLoss": {
            "Detect": "No ping/pong for 90s",
            "Action": [
              "Buffer telemetry to encrypted SQLite cache (AES-GCM)",
              "Retry with exponential backoff [30s, 2m, 10m, 30m]",
              "Auto resume WSS session on reconnect"
            ],
            "CachePolicy": {
              "max_size": "20MB",
              "max_age": "7d",
              "flush_on_reconnect": true
            }
          },
          "IntegrityFailure": {
            "Detect": "verify_signature() == false OR cert_expired == true",
            "Action": [
              "Drop invalid message",
              "Log incident to AuditTrail",
              "Notify Laravel via /api/alert/integrity"
            ]
          },
          "DeviceTamper": {
            "Detect": "Kernel telemetry event: TAMPER_DETECTED",
            "Action": [
              "Lock device through KernelService",
              "Generate alert in Laravel",
              "Push notification to MobileApp",
              "Flag session as compromised"
            ]
          }
        },
        "RecoverySession": {
          "Schema": {
            "id": "UUID",
            "started_at": "ISO8601 timestamp",
            "stage": "detect|retrying|restored|failed",
            "retries": "integer",
            "resolved_at": "ISO8601 timestamp",
            "root_cause": "error_code"
          },
          "Lifecycle": [
            "Session created on error detection",
            "Updated with each retry attempt",
            "Closed when success or marked failed",
            "Flushed to AuditTrail on completion"
          ]
        },
        "HealthLayer": {
          "Heartbeat": {
            "Interval": "60s",
            "Agents": [
              "WindowsAgent",
              "FastAPI",
              "Laravel"
            ],
            "FailurePolicy": "2 consecutive misses => degraded",
            "LaravelEndpoint": "POST /api/health/update"
          },
          "Aggregation": {
            "LaravelHealthAPI": "/api/health",
            "Returns": {
              "agent_status": "online|degraded|offline",
              "fastapi_status": "online|degraded|offline",
              "redis_status": "healthy|unreachable",
              "overall_state": "green|yellow|red"
            }
          }
        },
        "SelfHealing": {
          "SafeMode": {
            "Trigger": "3+ consecutive failures or kernel panic",
            "Action": [
              "Reduce module activity to critical-only telemetry",
              "Disable high-privilege operations",
              "Enable watchdog repair tasks"
            ]
          },
          "AutoRepair": {
            "Detect": "Corrupted agent binary or config",
            "Action": [
              "Re-download verified binary",
              "Validate hash and signature",
              "Restart agent service"
            ]
          },
          "RemoteReset": {
            "Initiator": "Laravel Admin Command",
            "Action": [
              "Revoke active session",
              "Force full re-pairing handshake"
            ]
          }
        },
        "AuditTrail": {
          "Storage": "Immutable JSON log chain",
          "Location": "MySQL + S3 replication",
          "Schema": {
            "event_id": "UUID",
            "timestamp": "ISO8601",
            "component": "Agent|Kernel|Laravel|FastAPI",
            "event_type": "error|alert|recovery|tamper",
            "payload_hash": "SHA256",
            "signature": "ed25519",
            "previous_hash": "SHA256"
          },
          "Integrity": "Each entry hash-linked to previous for tamper-evident trail"
        },
        "EscalationLayer": {
          "Channels": [
            "Laravel Mobile Push",
            "Email (Queue Worker)",
            "Dashboard WebSocket Alert",
            "Webhook to external SIEM endpoint"
          ],
          "SeverityMapping": {
            "low": "log only",
            "medium": "push + dashboard alert",
            "high": "push + email + webhook"
          }
        }
      },

      "7. PolicyEnforcementFlow": {
        "_comment": "Centralized policy engine with local caching and enforcement at the Agent for safety and availability.",
        "Purpose": "Ensure all commands conform to security, ethical, and organizational policies before execution.",
        "Actors": [
          "Laravel PolicyEngine",
          "FastAPI Controller",
          "WindowsAgent"
        ],
        "Sequence": [
          {
            "Step": "Policy evaluation",
            "Request": {
              "from": "Laravel",
              "to": "PolicyEngine",
              "action": "evaluate",
              "body": {
                "user": "UID001",
                "command": "lock_screen",
                "device": "PC001"
              }
            },
            "Process": "PolicyEngine checks rule base (RBAC, time window, device state, sensitivity, ethical flags).",
            "Response": {
              "allowed": true,
              "reason": "RBAC:AdminRole"
            }
          },
          {
            "Step": "Policy version broadcast",
            "Trigger": "Policy update or revocation",
            "Process": "Laravel publishes new policy_hash + version_id to FastAPI; FastAPI relays to Agents via WSS.",
            "Result": "All Agents refresh cached policy_bundle.json.enc"
          },
          {
            "Step": "Runtime enforcement at Agent",
            "Process": "Agent mirrors central policy; validates command against cached rules before kernel execution.",
            "Fallback": "If central unreachable, uses last trusted policy_bundle.json.enc"
          },
          {
            "Step": "Audit logging",
            "Process": "PolicyEngine signs each decision log with PolicyPriv and stores in immutable AuditTrail.",
            "Data": {
              "user": "UID001",
              "command": "lock_screen",
              "decision": "allow",
              "timestamp": "ISO8601"
            }
          },
          {
            "Step": "Violation handling",
            "Case": "Policy breach or expired key",
            "Action": [
              "Reject command",
              "Flag device/user in SecurityFlow",
              "Notify admin via Laravel webhook"
            ]
          }
        ],
        "Storage": "Policy rules and logs stored in Vault + append-only AuditTrail (S3/immutable DB)",
        "Categories": [
          "CommandPolicy",
          "DevicePolicy",
          "TimePolicy",
          "RatePolicy",
          "EthicalPolicy"
        ]
      }
    },

    "8. DataSchemaModel": {
      "_comment": "Persistent storage design for MySQL, Redis, and ObjectStore. Useful for DB schema diagrams and SQL table creation scripts.",
      "Purpose": "Define persistent storage model across MySQL, Redis, and ObjectStore.",
      "MySQL": {
        "Tables": {
          "users": [
            "id",
            "email",
            "pubkey",
            "role",
            "created_at"
          ],
          "devices": [
            "id",
            "user_id",
            "hwid",
            "status",
            "last_seen",
            "policy_hash"
          ],
          "commands": [
            "id",
            "device_id",
            "message_id",
            "method",
            "state",
            "queued_at",
            "completed_at",
            "trace_id"
          ],
          "telemetry_events": [
            "id",
            "device_id",
            "cpu",
            "ram",
            "disk_usage",
            "risk_score",
            "timestamp"
          ],
          "updates": [
            "id",
            "release_id",
            "version",
            "status",
            "staged",
            "rolled_back"
          ],
          "audits": [
            "id",
            "actor",
            "event_type",
            "payload_hash",
            "signature",
            "timestamp"
          ]
        }
      },
      "Redis": {
        "Keys": [
          "agent:online:*",
          "stream:device:*",
          "stream:telemetry:*",
          "stream:updates:*",
          "stream:dlq:*"
        ],
        "PubSubChannels": [
          "alerts",
          "rollout_updates",
          "policy_broadcasts"
        ]
      },
      "ObjectStore": {
        "Buckets": [
          "artifacts",
          "snapshots",
          "telemetry_blobs",
          "update_packages"
        ]
      },
      "Retention": {
        "hot_data_days": 90,
        "cold_archive_years": 3
      }
    },

    "9. MobileAppFlow": {
      "_comment": "Mobile UX/technical flow. Flutter chosen for Android + iOS cross-platform capability.",
      "Purpose": "Enable user to securely pair, monitor, and control their own device.",
      "Framework": "Flutter (cross-platform)",
      "Functions": [
        "Pair device via QR code",
        "View live telemetry (CPU, RAM, alerts)",
        "Send safe commands (lock screen, reboot, sync telemetry)",
        "Receive command results and notifications via WebSocket",
        "View audit and update logs"
      ],
      "Security": {
        "storage": "Encrypted SharedPreferences / Keychain",
        "biometric_lock": true,
        "jwt_refresh_ttl": "1h",
        "two_factor_required": true,
        "input_validation": "Strict schema enforcement"
      },
      "OfflineHandling": {
        "queue_limit": 3,
        "retry_backoff": [
          10,
          30,
          120
        ],
        "sync_on_reconnect": true
      },
      "UIEvents": [
        {
          "trigger": "device_paired",
          "action": "displaySuccessToast"
        },
        {
          "trigger": "command_completed",
          "action": "showResultDialog"
        },
        {
          "trigger": "alert_push",
          "action": "showCriticalBanner"
        }
      ]
    },

    "10. DashboardAnalyticsFlow": {
      "_comment": "Admin dashboard + analytics design (Laravel + Vue recommended).",
      "Purpose": "Provide administrators and researchers with live, auditable system visibility.",
      "Framework": "Laravel + Vue.js Dashboard",
      "Widgets": [
        "Device Health Overview (online/offline, uptime)",
        "Command Timeline & Status (per device)",
        "Update Rollout Progress and Failure Rate",
        "Security & Policy Alerts feed",
        "Audit Log Browser with filtering and export"
      ],
      "DataSources": [
        "MySQL",
        "Redis",
        "FastAPI WSS",
        "ObjectStore"
      ],
      "AccessControl": {
        "roles": [
          "admin",
          "auditor",
          "student"
        ],
        "permissions": {
          "admin": [
            "control",
            "policy_edit",
            "view_audit"
          ],
          "auditor": [
            "view_only"
          ],
          "student": [
            "read_only"
          ]
        }
      },
      "Exports": {
        "formats": [
          "CSV",
          "PDF",
          "JSON"
        ],
        "signed": true,
        "signature_algo": "Ed25519"
      }
    },

    "11. SystemWideProperties": {
      "_comment": "Global configuration values, security posture, reliability and privacy summary.",
      "Security": {
        "transport_encryption": "TLS 1.3 + optional mTLS",
        "payload_encryption": "AES-256-GCM",
        "signing_algorithm": "Ed25519 or RSA-PSS",
        "integrity_hash": "SHA-256",
        "auth": "JWT (short-lived) + 2FA",
        "key_rotation_days": 7,
        "audit_tamper_protection": "Hash-linked chain + S3 replication"
      },
      "Reliability": {
        "offline_queue_limit": 3,
        "dlq_policy": "3 retries -> stream:dlq",
        "heartbeat_interval": "30s",
        "self_heal": "auto-repair agent, safe-mode on 3+ failures"
      },
      "Observability": {
        "metrics": [
          "command_ingest_rate",
          "dispatch_latency_ms",
          "execution_time_ms",
          "success_rate",
          "dlq_count"
        ],
        "tracing": "Distributed tracing (trace_id propagation)",
        "logging": "Structured JSON with trace_id",
        "alert_channels": [
          "Dashboard",
          "Mobile Push",
          "Email",
          "Webhook"
        ]
      },
      "EthicsAndPrivacy": {
        "consent_required": true,
        "redaction": "sensitive fields (usernames, file paths) must be redacted in shared artifacts",
        "opt_in_categories": [
          "telemetry_basic",
          "updates"
        ],
        "no_surveillance": "No unauthorized screen capture, file exfiltration, or secret harvesting; sensitive commands require explicit owner consent and 2FA",
        "audit_visibility": "User can view all actions taken on their device"
      }
    },

    "12. SystemNotes": {
      "_comment": "Operational and academic notes to include in submission and lab setup instructions.",
      "Compliance": "For academic research use only; do not deploy for real-world monitoring of third-party systems.",
      "TestingEnvironment": "Closed virtual lab network, isolated VMs or physical lab machines.",
      "BuildPipeline": {
        "languages": [
          "C/C++ (kernel + agent native components)",
          "Python (FastAPI, analytics workers)",
          "PHP (Laravel)",
          "Dart (Flutter for mobile)"
        ],
        "ci_cd": "GitHub Actions + automated unit and integration tests",
        "artifact_signing": "detached signature verified by public key"
      },
      "NextSteps": {
        "generate_mermaid_diagram": true,
        "produce_pdf_appendix": true,
        "prepare_live_lab_demo": true
      }
    }
  }
}
